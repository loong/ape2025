# Interactive Art Image Streaming Application - PRD

## Project Overview
An interactive art installation that displays streams of images from a Python backend on multiple web canvases. Each canvas has a unique identifier (slug) and can receive independent image streams. The system will eventually be expanded to respond to audience voice input (not part of this initial scope). This PRD focuses on building the core image streaming functionality with support for multiple canvases.

## Core Requirements

### Backend (Python)
- Create a Python backend capable of:
  - Loading images using Pillow
  - Streaming these images to specific web canvases at up to 4 FPS
  - Tracking and sending timestamps for each image
  - Managing multiple canvas connections independently
  - Running locally (no cloud deployment needed at this stage)

### Frontend (Web)
- Create a minimal, distraction-free web interface that:
  - Displays multiple canvases, each with a unique identifier
  - Shows images streamed from the Python backend to specific canvases
  - Shows timestamps for when images change
  - Has no visible buttons or controls
  - Can handle images up to 4K resolution (though initial implementation will use 500-800px images)
  - Takes up the full viewport with no UI chrome
  - Uses responsive design to adapt to different screen sizes

### Communication Protocol
- Implement WebSockets for real-time, low-latency communication between frontend and backend
- Support canvas-specific WebSocket connections using unique slugs
- Ensure the system can maintain close to 4 FPS streaming rate per canvas

## Technical Specifications

### Backend
- **Language/Framework**: Python 3.8+ with FastAPI
- **Image Processing**: Pillow
- **WebSocket Library**: FastAPI's built-in WebSocket support
- **Development Server**: Uvicorn
- **Canvas Management**: Dictionary-based connection tracking with unique slugs

### Frontend
- **Framework**: React (widely used and well-supported)
- **WebSocket Client**: native WebSocket API or socket.io-client
- **Styling**: Minimal CSS, potentially using styled-components
- **Canvas Component**: Reusable React component for individual canvases

### Communication
- **Protocol**: WebSockets
- **Data Format**: JSON for metadata with Base64-encoded images
- **Message Structure**:
  ```json
  {
    "timestamp": "2025-04-15T14:30:00.000Z",
    "image": "base64_encoded_image_data_here",
    "image_id": "unique_identifier"
  }
  ```

## Implementation Details

### Backend (Python)

#### Setup
```python
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from PIL import Image
import io
import base64
import datetime
import asyncio
import uuid
from typing import Dict, Set

app = FastAPI()

# Allow CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # For development only
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Store active connections per canvas
canvas_connections: Dict[str, Set[WebSocket]] = {
    "left-canva": set(),
    "right-canva": set()
}
```

#### WebSocket Connection Handling
```python
@app.websocket("/ws/{canvas_slug}")
async def websocket_endpoint(websocket: WebSocket, canvas_slug: str):
    if canvas_slug not in canvas_connections:
        await websocket.close()
        return
    
    await websocket.accept()
    canvas_connections[canvas_slug].add(websocket)
    try:
        while True:
            await websocket.receive_text()
    except Exception:
        canvas_connections[canvas_slug].remove(websocket)
```

#### Image Streaming Function
```python
async def send_image(img: Image.Image, canvas_slug: str):
    """
    Send a PIL Image to all connected clients of a specific canvas.
    """
    if canvas_slug not in canvas_connections:
        return
    
    connections = canvas_connections[canvas_slug]
    if not connections:
        return
    
    # Process and send image to specific canvas
    buffer = io.BytesIO()
    img.save(buffer, format="JPEG")
    img_str = base64.b64encode(buffer.getvalue()).decode('utf-8')
    
    message = {
        "timestamp": datetime.datetime.now().isoformat(),
        "image": img_str,
        "image_id": str(uuid.uuid4())
    }
    
    for connection in list(connections):
        try:
            await connection.send_json(message)
        except Exception:
            connections.remove(connection)
```

#### API for Testing
```python
@app.get("/test-stream/{num_images}/{fps}")
async def test_stream(num_images: int = 10, fps: float = 1.0):
    """
    Test endpoint that streams a sequence of test images.
    """
    # Implementation would load a sequence of test images
    # and stream them at the specified FPS
    sleep_time = 1.0 / fps
    
    for i in range(num_images):
        # This would use actual images in production
        test_image_path = f"test_images/image_{i}.jpg"
        await send_image(Image.open(test_image_path), "left-canva")
        await asyncio.sleep(sleep_time)
    
    return {"status": "complete"}
```

#### Main Function
```python
if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
```

### Frontend (React)

#### Canvas Component
```jsx
function Canvas({ slug }) {
  const [imageData, setImageData] = useState(null);
  const [timestamp, setTimestamp] = useState(null);
  const [socket, setSocket] = useState(null);

  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:8000/ws/${slug}`);
    
    ws.onopen = () => {
      console.log(`Connected to the server for ${slug}`);
      // Keep connection alive
      setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send('ping');
        }
      }, 30000);
    };
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setImageData(`data:image/jpeg;base64,${data.image}`);
      
      // Format timestamp for display
      const date = new Date(data.timestamp);
      setTimestamp(date.toLocaleTimeString() + '.' + 
                  date.getMilliseconds().toString().padStart(3, '0'));
    };
    
    ws.onerror = (error) => {
      console.error(`WebSocket error for ${slug}:`, error);
    };
    
    ws.onclose = () => {
      console.log(`Disconnected from the server for ${slug}`);
    };
    
    setSocket(ws);
    
    // Cleanup on component unmount
    return () => {
      if (ws) {
        ws.close();
      }
    };
  }, [slug]);

  return (
    <div className="canvas-container">
      <div className="image-container">
        {imageData ? (
          <img src={imageData} alt={`Streamed content for ${slug}`} />
        ) : (
          <div className="placeholder">Waiting for image stream...</div>
        )}
      </div>
      {timestamp && <div className="timestamp">{timestamp}</div>}
      <div className="canvas-label">{slug}</div>
    </div>
  );
}
```

#### App Component
```jsx
function App() {
  return (
    <div className="app-container">
      <Canvas slug="left-canva" />
      <Canvas slug="right-canva" />
    </div>
  );
}
```

## Utility Functions for the Backend

### Image Directory Monitor
```python
import os
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class ImageHandler(FileSystemEventHandler):
    def __init__(self, callback):
        self.callback = callback
        self.last_modified = {}
        
    def on_created(self, event):
        if not event.is_directory and self._is_image_file(event.src_path):
            self.callback(event.src_path)
            
    def on_modified(self, event):
        if not event.is_directory and self._is_image_file(event.src_path):
            current_time = time.time()
            if event.src_path in self.last_modified:
                # Ensure we don't process the same file multiple times
                if current_time - self.last_modified[event.src_path] > 0.5:
                    self.callback(event.src_path)
            else:
                self.callback(event.src_path)
            self.last_modified[event.src_path] = current_time
            
    def _is_image_file(self, path):
        ext = os.path.splitext(path)[1].lower()
        return ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp']

def monitor_directory(directory_path, callback):
    event_handler = ImageHandler(callback)
    observer = Observer()
    observer.schedule(event_handler, directory_path, recursive=True)
    observer.start()
    return observer
```

## Testing and Development

### Running the Backend
1. Install dependencies:
   ```
   pip install fastapi uvicorn pillow python-multipart watchdog websockets
   ```

2. Create a directory for test images.

3. Run the server:
   ```
   python main.py
   ```

### Running the Frontend
1. Create a new React app:
   ```
   npx create-react-app image-stream-frontend
   cd image-stream-frontend
   ```

2. Replace the src/App.js and src/App.css files with the code provided above.

3. Start the development server:
   ```
   npm start
   ```

## Next Steps and Future Enhancements
1. Add the audio input processing to influence image selection
2. Implement image transitions/effects
3. Add multi-display support if needed
4. Optimize image streaming for better performance
5. Implement security measures before public deployment
6. Add dynamic canvas creation/removal
7. Implement canvas-specific image processing

## Performance Considerations
- Monitor CPU and memory usage during extended operations
- Implement adaptive quality based on connection speed
- Consider using WebP format for better compression while maintaining quality
- Implement proper error handling and recovery mechanisms
- Monitor connection counts per canvas to prevent overload